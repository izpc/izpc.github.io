<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>创建 PostgreSQL 用户和数据库</title>
      <link href="/2024/04/22/create-postgres-user-and-database/"/>
      <url>/2024/04/22/create-postgres-user-and-database/</url>
      
        <content type="html"><![CDATA[<h1 id="简化-SQL-语句，-注意高版本的-PostgreSQL-需要使用-GRANT-命令"><a href="#简化-SQL-语句，-注意高版本的-PostgreSQL-需要使用-GRANT-命令" class="headerlink" title="简化 SQL 语句， 注意高版本的 PostgreSQL 需要使用 GRANT 命令"></a>简化 SQL 语句， 注意高版本的 PostgreSQL 需要使用 <code>GRANT</code> 命令</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">create</span> role foo <span class="keyword">with</span> login password <span class="string">&#x27;yourpassword&#x27;</span> valid until <span class="string">&#x27;infinity&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 高版本需要使用这个命令</span></span><br><span class="line"><span class="keyword">GRANT</span> foo <span class="keyword">TO</span> postgres;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database bar <span class="keyword">with</span> encoding<span class="operator">=</span><span class="string">&#x27;UTF8&#x27;</span> owner<span class="operator">=</span>foo connection limit<span class="operator">=</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">REVOKE</span> foo <span class="keyword">FROM</span> postgres;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Reference: </p><ol><li><a href="https://www.cnblogs.com/zhangpengshou/p/5464610.html">ubuntu下postgreSQL安装配置</a></li><li><a href="https://www.postgresql.org/docs/9.1/backup-dump.html#BACKUP-DUMP-RESTORE">Backup&amp;Restore</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Authentik 使用钉钉登录</title>
      <link href="/2024/04/10/authentik-use-dingtalk-login/"/>
      <url>/2024/04/10/authentik-use-dingtalk-login/</url>
      
        <content type="html"><![CDATA[<h1 id="Authentik-使用钉钉登录"><a href="#Authentik-使用钉钉登录" class="headerlink" title="Authentik 使用钉钉登录"></a>Authentik 使用钉钉登录</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Authentik 是一个开源的身份验证和授权服务，它提供了一种简单的方式来添加用户身份验证和授权功能到您的应用程序中。Authentik 支持多种身份验证方式，包括用户名密码、社交登录、LDAP 等。</p><p>钉钉是一款企业级即时通讯和协作工具，它提供了丰富的 API 和 SDK，可以用于集成企业内部系统和第三方应用。</p><p>在这个示例中，我们将演示如何使用 Authentik 集成钉钉登录，以便用户可以使用他们的钉钉账户登录到您的应用程序中。</p><p>钉钉是有 OAuth2 授权机制的，我们将使用 Authentik 的 OAuth2 提供程序来实现钉钉登录。</p><p>Authentik 的 OAuth2 提供程序允许您将任何符合 OAuth2 标准的身份验证服务集成到 Authentik 中，以便用户可以使用这些服务登录到您的应用程序中。<a href="https://docs.goauthentik.io/integrations/sources/oauth/">参见文档</a></p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-创建钉钉应用"><a href="#1-创建钉钉应用" class="headerlink" title="1. 创建钉钉应用"></a>1. 创建钉钉应用</h3><p>可以参见 Gitlab 的文档 <a href="https://docs.gitlab.com/ee/integration/ding_talk.html">DingTalk 集成</a> 或 Casdoor 的文档 <a href="https://casdoor.org/zh/docs/provider/oauth/DingTalk/">DingTalk OAuth</a> 来创建一个钉钉应用。</p><h4 id="1-1-OAuth-接口说明"><a href="#1-1-OAuth-接口说明" class="headerlink" title="1.1 OAuth 接口说明"></a>1.1 OAuth 接口说明</h4><p>参见文档：<a href="https://open.dingtalk.com/document/orgapp/obtain-identity-credentials">获取登录用户的访问凭证</a></p><p>在 github 找到一个<a href="https://github.com/directus/directus/discussions/11881">示例</a></p><details><summary>示例代码</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Dingtalk is an enterprise communication tool similar to Jira/Confluence/WhatApp. It provides OAuth 2 service. The protocol is as below.</span><br><span class="line"></span><br><span class="line">OAuth2 protocol, Dingtalk version</span><br><span class="line">Auth</span><br><span class="line">GET https://login.dingtalk.com/oauth2/auth?</span><br><span class="line">redirect_uri=https%3A%2F%2Fwww.baidu.com%2F&amp;response_type=code&amp;client_id=dingyourclientid&amp;scope=openid&amp;prompt=consent</span><br><span class="line"></span><br><span class="line">The redirect callback after Auth will be with below format:</span><br><span class="line">https://www.baidu.com/?authCode=6b427e8bfab83e93bedd13f16a430702</span><br><span class="line"></span><br><span class="line">Get token</span><br><span class="line">POST https://api.dingtalk.com/v1.0/oauth2/userAccessToken</span><br><span class="line">Content-Type:application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;clientId&quot; : &quot;ding your id&quot;,</span><br><span class="line">  &quot;clientSecret&quot; : &quot;your secret&quot;,</span><br><span class="line">  &quot;code&quot; : &quot;6b427e8bfab83e93bedd13f16a430702&quot;,</span><br><span class="line">  &quot;grantType&quot; : &quot;authorization_code&quot;</span><br><span class="line">&#125;</span><br><span class="line">The response will be</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;expireIn&quot;: 7200,</span><br><span class="line">  &quot;accessToken&quot;: &quot;a8f4e3215a703ce9a7164e91dbab53c0&quot;,</span><br><span class="line">  &quot;refreshToken&quot;: &quot;b13e5a61b421342d95d86c9e64c275c6&quot;</span><br><span class="line">&#125;</span><br><span class="line">Retrieve user info</span><br><span class="line">GET https://api.dingtalk.com/v1.0/contact/users/me</span><br><span class="line">x-acs-dingtalk-access-token:a8f4e3215a703ce9a7164e91dbab53c0</span><br><span class="line">Content-Type:application/json</span><br><span class="line"></span><br><span class="line">Response will be</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;nick&quot;: &quot;AWIS ME&quot;,</span><br><span class="line">  &quot;unionId&quot;: &quot;D578iS5hxxxx&quot;,</span><br><span class="line">  &quot;avatarUrl&quot;: &quot;https://static-legacy.dingtalk.com/media/lADPGT5i9m5ZyXDNA4LNAtA_720.jpg&quot;,</span><br><span class="line">  &quot;openId&quot;: &quot;WySPOpXqxE&quot;,</span><br><span class="line">  &quot;mobile&quot;: &quot;1350xxxxxxxx&quot;,</span><br><span class="line">  &quot;stateCode&quot;: &quot;86&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;xxxu@xxx.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>以及一些其他服务集成的代码样例 <a href="https://github.com/xu4wang/apiproxy/blob/main/src/handlers/oauth_dingtalk.ts">apiproxy</a> 和 <a href="https://github.com/ory/kratos/blob/eb67bed1f26d2c7ff10e5481b679b2213b44676d/selfservice/strategy/oidc/provider_dingtalk.go">kratos</a></p><h3 id="2-配置-Authentik"><a href="#2-配置-Authentik" class="headerlink" title="2. 配置 Authentik"></a>2. 配置 Authentik</h3><p>可以参见配置 Twtich 的文档 <a href="https://docs.goauthentik.io/integrations/sources/twitch/">Twitch 集成</a></p><p>记得要选择 OpenID Connect 作为身份验证类型。</p><p>注意 <code>Scopes</code> 要填写 *openid, <code>Authorization URL</code> 要填写 <a href="https://login.dingtalk.com/oauth2/auth?prompt=consent">https://login.dingtalk.com/oauth2/auth?prompt=consent</a></p><p>至于 <code>Token URL</code> 和 <code>User Info URL</code> 可以则需要自定义转化服务的 URL， 这是因为钉钉的 OAuth2 接口是非标准的（命名方法不一样，参数内容也有一些细微差异），所以需要自己实现一个 OAuth2 提供程序。可参见<a href="https://zhuanlan.zhihu.com/p/666423994">这篇文章</a></p><h3 id="3-实现-OAuth2-提供程序"><a href="#3-实现-OAuth2-提供程序" class="headerlink" title="3. 实现 OAuth2 提供程序"></a>3. 实现 OAuth2 提供程序</h3><p>我是使用 aws serverless 来实现的，代码如下：</p><details><summary> /auth/dingtalk/token </summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> parse_qs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TOKEN_URL = <span class="string">&#x27;https://api.dingtalk.com/v1.0/oauth2/userAccessToken&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_form_data_to_json</span>(<span class="params">form_data</span>):</span><br><span class="line">    parsed_data = parse_qs(form_data)</span><br><span class="line">    result = &#123;k: v[<span class="number">0</span>] <span class="keyword">for</span> k, v <span class="keyword">in</span> parsed_data.items()&#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;event:\n<span class="subst">&#123;event&#125;</span>&quot;</span>)</span><br><span class="line">    s = event.get(<span class="string">&quot;body&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> event.get(<span class="string">&quot;isBase64Encoded&quot;</span>) <span class="keyword">and</span> s:</span><br><span class="line">        s = b64decode(s).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    body = parse_form_data_to_json(s)</span><br><span class="line"></span><br><span class="line">    headers = &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>&#125;</span><br><span class="line">    response = requests.post(TOKEN_URL, json=&#123;</span><br><span class="line">        <span class="string">&#x27;clientId&#x27;</span>: body.get(<span class="string">&#x27;client_id&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;clientSecret&#x27;</span>: body.get(<span class="string">&#x27;client_secret&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;code&#x27;</span>: body.get(<span class="string">&#x27;code&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;grantType&#x27;</span>: body.get(<span class="string">&#x27;grant_type&#x27;</span>),</span><br><span class="line">    &#125;, headers=headers)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line">    res = response.json()</span><br><span class="line"></span><br><span class="line">    result = &#123;</span><br><span class="line">        <span class="comment"># &#x27;refresh_token&#x27;: result.get(&#x27;refreshToken&#x27;),</span></span><br><span class="line">        <span class="string">&#x27;access_token&#x27;</span>: res.get(<span class="string">&#x27;accessToken&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;expires_in&#x27;</span>: res.get(<span class="string">&#x27;expiresIn&#x27;</span>),</span><br><span class="line">        <span class="string">&#x27;token_type&#x27;</span>: <span class="string">&#x27;Bearer&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;statusCode&quot;</span>: <span class="number">200</span>, <span class="string">&quot;body&quot;</span>: json.dumps(result)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details><summary> /auth/dingtalk/profile </summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">URL = <span class="string">&#x27;https://api.dingtalk.com/v1.0/contact/users/me&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">event, context</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;event:\n<span class="subst">&#123;event&#125;</span>&quot;</span>)</span><br><span class="line">    access_token = event.get(<span class="string">&#x27;headers&#x27;</span>, &#123;&#125;).get(<span class="string">&#x27;authorization&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    access_token = access_token.replace(<span class="string">&#x27;Bearer &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(access_token)</span><br><span class="line"></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">        <span class="string">&#x27;x-acs-dingtalk-access-token&#x27;</span>: access_token,</span><br><span class="line">    &#125;</span><br><span class="line">    response = requests.get(URL, headers=headers)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line">    user_info = response.json()</span><br><span class="line">    <span class="built_in">print</span>(user_info)</span><br><span class="line"></span><br><span class="line">    result = &#123;</span><br><span class="line">        <span class="comment"># &#x27;issuer&#x27;: userInfoURL,</span></span><br><span class="line">        <span class="comment"># &#x27;picture&#x27;: user_info.get(&#x27;avatarUrl&#x27;),</span></span><br><span class="line">        <span class="string">&#x27;sub&#x27;</span>: user_info[<span class="string">&#x27;openId&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;nickname&#x27;</span>: user_info[<span class="string">&#x27;nick&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: user_info[<span class="string">&#x27;nick&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span>: user_info[<span class="string">&#x27;email&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;statusCode&quot;</span>: <span class="number">200</span>, <span class="string">&quot;body&quot;</span>: json.dumps(result)&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><h4 id="错误排查"><a href="#错误排查" class="headerlink" title="错误排查"></a>错误排查</h4><p>如果出现 <code>Could not determine id.</code> 的错误，可以参见 <a href="https://github.com/goauthentik/authentik/blob/main/authentik/sources/oauth/types/oidc.py">源码解决</a> 来解决， 我当时处理少了 sub 参数。报错实现的<a href="https://github.com/goauthentik/authentik/blob/main/authentik/sources/oauth/views/callback.py#L59">具体代码</a>可以定位。</p><p>在日志中可以根据关键字查找到源码， 日志如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;auth_via&quot;: &quot;unauthenticated&quot;, &quot;domain_url&quot;: &quot;example.com&quot;, &quot;event&quot;: &quot;Authentication Failure&quot;, &quot;host&quot;: &quot;example.com&quot;, &quot;level&quot;: &quot;warning&quot;, &quot;logger&quot;: &quot;authentik.sources.oauth.views.callback&quot;, &quot;pid&quot;: 4721, &quot;reason&quot;: &quot;Could not determine id.&quot;, &quot;request_id&quot;: &quot;28a8d8818c63441da41051455c32d437&quot;, &quot;schema_name&quot;: &quot;public&quot;, &quot;timestamp&quot;: &quot;2024-04-09T10:30:48.464283&quot;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> authentik </tag>
            
            <tag> dingtalk </tag>
            
            <tag> aws </tag>
            
            <tag> serverless </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT 帮助之 Kubectl 查询镜像</title>
      <link href="/2024/03/27/chatgpt-help-find-k8s-images/"/>
      <url>/2024/03/27/chatgpt-help-find-k8s-images/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubectl查询脚本"><a href="#Kubectl查询脚本" class="headerlink" title="Kubectl查询脚本"></a>Kubectl查询脚本</h1><h2 id="用户"><a href="#用户" class="headerlink" title="用户:"></a>用户:</h2><p>帮我写一个脚本使用 kubectl 查询集群上所有 pod image 以 docker.foobar.com 开头的镜像列表，去重排序</p><h2 id="ChatGPT"><a href="#ChatGPT" class="headerlink" title="ChatGPT:"></a>ChatGPT:</h2><p>要编写一个脚本来查询 Kubernetes 集群上所有以 <code>docker.foobar.com</code> 开头的 Pod 镜像，并进行去重排序，我们可以使用 <code>kubectl</code> 命令行工具和一些文本处理工具，如 <code>awk</code>, <code>sort</code>, <code>uniq</code> 等。</p><p>以下是一个简单的 Bash 脚本示例，它将执行这些操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询集群上所有 pod 的镜像信息</span></span><br><span class="line">images=$(kubectl get pods --all-namespaces -o jsonpath=<span class="string">&quot;&#123;..image&#125;&quot;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27;[[:space:]]&#x27;</span> <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤出以 docker.foobar.com 开头的镜像，并去重排序</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$images</span>&quot;</span> | grep <span class="string">&#x27;^docker\.foobar\.com&#x27;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个脚本的工作流程如下：</p><ol><li>使用 <code>kubectl get pods --all-namespaces -o jsonpath=&quot;&#123;..image&#125;&quot;</code> 获取集群中所有命名空间的所有 Pod 的镜像信息。</li><li>使用 <code>tr -s &#39;[[:space:]]&#39; &#39;\n&#39;</code> 将输出中的空格转换为换行符，这样每个镜像都在单独的一行。</li><li>使用 <code>grep &#39;^docker\.foobar\.com&#39;</code> 来过滤出以 <code>docker.foobar.com</code> 开头的镜像。</li><li>使用 <code>sort</code> 对结果进行排序。</li><li>使用 <code>uniq</code> 命令去除重复的镜像。</li></ol><p>要运行这个脚本，你需要在一个有 <code>kubectl</code> 访问权限的环境中执行以下步骤：</p><ol><li>将上面的脚本保存为一个文件，例如 <code>get-foobar-images.sh</code>。</li><li>通过运行 <code>chmod +x get-foobar-images.sh</code> 命令使脚本可执行。</li><li>运行脚本 <code>./get-foobar-images.sh</code>。</li></ol><p>请确保你的 <code>kubectl</code> 配置正确，并且你有足够的权限来查询所有命名空间中的 Pods。</p><h2 id="用户-1"><a href="#用户-1" class="headerlink" title="用户:"></a>用户:</h2><p>一行实现</p><h2 id="ChatGPT-1"><a href="#ChatGPT-1" class="headerlink" title="ChatGPT:"></a>ChatGPT:</h2><p>可以使用一条命令行语句来完成这个任务。在 shell 中，您可以使用管道（<code>|</code>）来连接多个命令，形成一个单一的命令行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --all-namespaces -o jsonpath=<span class="string">&quot;&#123;..image&#125;&quot;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27;[[:space:]]&#x27;</span> <span class="string">&#x27;\n&#x27;</span> | grep <span class="string">&#x27;^docker\.foobar\.com&#x27;</span> | <span class="built_in">sort</span> -u</span><br></pre></td></tr></table></figure><p>这条命令解释如下：</p><ul><li><code>kubectl get pods --all-namespaces -o jsonpath=&quot;&#123;..image&#125;&quot;</code>：获取所有命名空间中的 Pods 的镜像信息。</li><li><code>tr -s &#39;[[:space:]]&#39; &#39;\n&#39;</code>：将输出中的空格和换行符压缩成单个换行符，以便每个镜像占一行。</li><li><code>grep &#39;^docker\.foobar\.com&#39;</code>：过滤出以 <code>docker.foobar.com</code> 开头的镜像。</li><li><code>sort -u</code>：对结果进行排序，并使用 <code>-u</code>（唯一）选项去除重复的行。</li></ul><p>您可以直接在终端中运行这条命令，前提是您已经配置了对应的 <code>kubectl</code> 访问权限。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT 帮助之 S3 移动对象</title>
      <link href="/2024/03/21/chatgpt-help-s3-move-object/"/>
      <url>/2024/03/21/chatgpt-help-s3-move-object/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p>如何将 s3:&#x2F;&#x2F;foobar&#x2F;expense&#x2F;2023&#x2F;12&#x2F;02 00:00:00&#x2F;2023-12-02 00:00:00.json 这个路径移动为 s3:&#x2F;&#x2F;foobar&#x2F;expense&#x2F;2023&#x2F;12&#x2F;02&#x2F;2023-12-02.json，并将2023-12-01 到今天的全部处理，最少python脚本实现</p></blockquote><h1 id="回答"><a href="#回答" class="headerlink" title="回答"></a>回答</h1><p>要将 S3 中的对象从一个键移动到另一个键，您需要执行一个复制操作，然后删除原始对象。在AWS中，移动并不是一个原子操作，而是由复制（COPY）和删除（DELETE）操作组成的。</p><p>下面是一个Python脚本示例，它使用<code>boto3</code>库（这是AWS的官方Python SDK）来移动指定日期范围内的文件。这个脚本会遍历给定日期范围内的每一天，构建原始和目标键，并执行必要的复制和删除操作。</p><p>安装<code>boto3</code>库（如果尚未安装）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install boto3</span><br></pre></td></tr></table></figure><p>Python脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化S3客户端</span></span><br><span class="line">s3_client = boto3.client(<span class="string">&#x27;s3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义S3桶名称</span></span><br><span class="line">bucket_name = <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定日期范围</span></span><br><span class="line">start_date = datetime.datetime(<span class="number">2023</span>, <span class="number">12</span>, <span class="number">1</span>)</span><br><span class="line">end_date = datetime.datetime.now()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历日期范围</span></span><br><span class="line">current_date = start_date</span><br><span class="line"><span class="keyword">while</span> current_date &lt;= end_date:</span><br><span class="line">    <span class="comment"># 构建原始和目标键</span></span><br><span class="line">    original_key = <span class="string">f&#x27;expense/<span class="subst">&#123;current_date.year&#125;</span>/<span class="subst">&#123;current_date.month:02d&#125;</span>/<span class="subst">&#123;current_date.day:02d&#125;</span> 00:00:00/<span class="subst">&#123;current_date.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)&#125;</span> 00:00:00.json&#x27;</span></span><br><span class="line">    new_key = <span class="string">f&#x27;expense/<span class="subst">&#123;current_date.year&#125;</span>/<span class="subst">&#123;current_date.month:02d&#125;</span>/<span class="subst">&#123;current_date.day:02d&#125;</span>/<span class="subst">&#123;current_date.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)&#125;</span>.json&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 复制对象</span></span><br><span class="line">    copy_source = &#123;</span><br><span class="line">        <span class="string">&#x27;Bucket&#x27;</span>: bucket_name,</span><br><span class="line">        <span class="string">&#x27;Key&#x27;</span>: original_key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s3_client.copy(copy_source, bucket_name, new_key)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Copied: <span class="subst">&#123;original_key&#125;</span> to <span class="subst">&#123;new_key&#125;</span>&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 删除原始对象</span></span><br><span class="line">        s3_client.delete_object(Bucket=bucket_name, Key=original_key)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Deleted: <span class="subst">&#123;original_key&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> s3_client.exceptions.NoSuchKey:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;No such key: <span class="subst">&#123;original_key&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Error: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 移至下一天</span></span><br><span class="line">    current_date += datetime.timedelta(days=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>请注意，这个脚本没有处理可能的分页。如果您有很多文件，您可能需要处理S3的分页响应。另外，请确保您的AWS凭证已经配置在环境变量中，或者您已经在<code>.aws/credentials</code>文件中配置了它们，否则您需要在创建<code>boto3.client</code>时手动提供它们。</p><p>在运行此脚本之前，请确保您有足够的权限来执行这些操作，并且您已经备份了重要数据，防止意外丢失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GPT </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echarts 添加堆叠工具选项</title>
      <link href="/2024/03/21/echarts-toolbox-add-stack/"/>
      <url>/2024/03/21/echarts-toolbox-add-stack/</url>
      
        <content type="html"><![CDATA[<p><a href="https://echarts.apache.org/en/option.html#toolbox.feature.magicType">https://echarts.apache.org/en/option.html#toolbox.feature.magicType</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    <span class="attr">toolbox</span>: &#123;</span><br><span class="line">        <span class="attr">feature</span>: &#123;</span><br><span class="line">            <span class="attr">magicType</span>: &#123;</span><br><span class="line">                <span class="attr">type</span>: [<span class="string">&#x27;line&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;stack&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">series</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>type 为 ‘stack’ 时，会将所有的 bar 类型的 series 堆叠在一起。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ECharts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让 JupyterHub 支持 LDAP</title>
      <link href="/2024/03/21/let-jupyterhub-support-ldap/"/>
      <url>/2024/03/21/let-jupyterhub-support-ldap/</url>
      
        <content type="html"><![CDATA[<p>JupyterHub 其实是支持的 LDAP 认证，但是模式是 LDAPS，对于没有 LDAP 非加密端口则不支持</p><p>下面是一段 Dockerfile, 用于修复这个问题</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> jupyterhub/k8s-hub:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> root </span><br><span class="line"><span class="comment"># Fix LDAP authenticator use_ssl issue</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> FILEPATH=`python -c <span class="string">&quot;import pkg_resources; import os; print(os.path.join(pkg_resources.get_distribution(&#x27;jupyterhub-ldapauthenticator&#x27;).location, &#x27;ldapauthenticator&#x27;, &#x27;ldapauthenticator.py&#x27;))&quot;</span>` &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">sed -i <span class="string">&#x27;s/ldap3.AUTO_BIND_NO_TLS if self.use_ssl else ldap3.AUTO_BIND_TLS_BEFORE_BIND/ldap3.AUTO_BIND_NO_TLS if not self.use_ssl else ldap3.AUTO_BIND_TLS_BEFORE_BIND/g&#x27;</span> <span class="variable">$&#123;FILEPATH&#125;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> jovyan</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JupyterHub </tag>
            
            <tag> LDAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手机和电脑</title>
      <link href="/2024/02/08/mobile-and-pc/"/>
      <url>/2024/02/08/mobile-and-pc/</url>
      
        <content type="html"><![CDATA[<p>最近在手机和电脑间切换，发现手机主要用于娱乐，使用上主要是方便，而电脑则是用于工作，使用上主要是偏向效率。</p><p>这两点的根本不同不能过于颠倒，比如你说用手机工作，用电脑娱乐。这种总是有些拧巴，为什么？</p><p>手机当前主要是触摸屏幕，所以对于容错性比较高的场景适用，而且最好是没有输入键盘的操作</p><p>电脑由于大部分不是触屏，所以对于精确效率的场景比较合适，尤其是键盘这种输入设备的操作</p><p>手机主要在于便携和多传感器，可以认为是一个采集终端</p><p>电脑主要在于物理设备和硬件，可以看作是一个处理中心</p><p>仔细品，看看现在这两个设备上的应用有哪些不同，以及流行的分别是什么就知道了，同时在开发对应的应用的同时也要按照这种设计顺应不同的方向，别搞反了，除非你是主打“差异化”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell 命令系列之 split 小技巧</title>
      <link href="/2024/01/05/shell-split-trick/"/>
      <url>/2024/01/05/shell-split-trick/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>这段代码有什么问题？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -b <span class="variable">$SPLIT_SIZE</span> <span class="string">&quot;<span class="variable">$file</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span>_part_&quot;</span></span><br></pre></td></tr></table></figure><p>答：如果是一行行的记录，在按照字节切割的时候会出现断行</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>我： 使用 shell split 切割文件 如何保证按照文件大小切割并且不断行？比如按照 100MB 文件大小</p><p>GPT: <code>split</code> 命令可以用来将文件分割成多个小文件。<code>-b</code> 参数可以用来指定每个小文件的大小。例如，如果你想将文件分割成每个100MB的小文件，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -b 100m file_name</span><br></pre></td></tr></table></figure><p>这将创建一系列的文件，名字为 <code>xaa</code>, <code>xab</code>, <code>xac</code> 等等，每个文件的大小都接近100MB。</p><p>但是，这种方法可能会在某些行的中间切割文件，这可能会导致问题，因为被切割的行可能无法正确解析。</p><p>如果你希望在分割文件时保持完整的行，那么你可以使用 <code>-C</code> 参数。这个参数允许你指定每个输出文件的最大行数，但是 <code>split</code> 命令会保证每个输出文件不会在一行的中间结束。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -C 100m file_name</span><br></pre></td></tr></table></figure><p>这将创建一系列的文件，每个文件的大小都接近但不超过100MB，并且每个文件都会在一个完整的行结束。但是，这个命令可能会导致每个输出文件的大小略微超过你指定的大小，因为它会包含最后一个完整的行，即使这会导致文件的大小超过你指定的大小。</p><p>注意：<code>-C</code> 参数可能在一些老版本的 <code>split</code> 中不可用。</p><p>我：详细解释下 -C 和 -b 的区别？</p><p>GPT: <code>split</code> 命令的 <code>-b</code> 和 <code>-C</code> 参数都用于指定输出文件的大小，但是它们在处理文件的行尾时有所不同。</p><p><code>-b</code> 参数指定了每个输出文件的字节大小。例如，<code>split -b 100m file_name</code> 将会把输入文件 <code>file_name</code> 分割成大小接近100MB的小文件。这个命令将在指定的字节位置处分割文件，不考虑这个位置是否在一行的中间。</p><p>另一方面，<code>-C</code> 参数也用于指定每个输出文件的字节大小，但是它会保证每个输出文件在一个完整的行结束。例如，<code>split -C 100m file_name</code> 将会把输入文件 <code>file_name</code> 分割成大小接近但不超过100MB的小文件，而且每个文件都会在一个完整的行结束。这意味着，如果一个文件的大小正好是100MB，但是最后一个字节恰好在一行的中间，那么 <code>split</code> 命令会将这整行包含在当前文件中，而不是将它分割到下一个文件中。这可能会导致输出文件的大小略微超过你指定的大小。</p><p>总的来说，如果你希望严格控制输出文件的大小，并且不关心文件是否在一行的中间被分割，那么你应该使用 <code>-b</code> 参数。如果你希望每个输出文件都在一个完整的行结束，那么你应该使用 <code>-C</code> 参数，但是这可能会导致输出文件的大小略微超过你指定的大小。</p><p>我：请给我一些测试代码测试这两个区别的实现</p><p>GPT: 好的，让我们创建一个包含多行文本的文件，然后使用 <code>split</code> 命令的 <code>-b</code> 和 <code>-C</code> 参数来分割它。</p><p>首先，我们创建一个文本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This is line 1</span></span><br><span class="line"><span class="string">This is line 2</span></span><br><span class="line"><span class="string">This is line 3</span></span><br><span class="line"><span class="string">This is line 4</span></span><br><span class="line"><span class="string">This is line 5&quot;</span> &gt; testfile.txt</span><br></pre></td></tr></table></figure><p>然后，我们可以使用 <code>-b</code> 参数来分割这个文件。我们将每个输出文件的大小设置为15字节：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -b 15 testfile.txt test_b_</span><br></pre></td></tr></table></figure><p>如果你查看 <code>test_b_aa</code> 和 <code>test_b_ab</code> 文件，你会看到它们被分割在了 “line 1” 和 “This is line 2” 之间，这是因为 “This is line 1\n” 正好是15字节。</p><p>现在，我们使用 <code>-C</code> 参数来分割同一个文件。我们还是将每个输出文件的大小设置为15字节：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">split</span> -C 15 testfile.txt test_C_</span><br></pre></td></tr></table></figure><p>这次，如果你查看 <code>test_C_aa</code> 和 <code>test_C_ab</code> 文件，你会看到它们被分割在了 “This is line 1” 和 “This is line 2” 之间，即使 “This is line 1\n” 超过了15字节。这是因为 <code>-C</code> 参数保证了每个输出文件都在一个完整的行结束。</p><p>请注意，这个例子是为了演示 <code>-b</code> 和 <code>-C</code> 参数的行为，实际上在大多数情况下，你会使用更大的文件和更大的输出文件大小。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>经过测试 15 字节是测不出来的，要 25，同时如果设为 5 字节（少于每行的字节数）也是有问题的，可以试试</p>]]></content>
      
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 状态码</title>
      <link href="/2024/01/03/http-status-code/"/>
      <url>/2024/01/03/http-status-code/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>HTTP状态码用于表示一个HTTP请求是否成功，以及在不成功的情况下出现了什么类型的错误。状态码分为几个范围，每个范围代表了一类响应。</p><p>1xx（100-199）：信息性状态码，表示接收的请求正在处理。<br>2xx（200-299）：成功状态码，表示请求正常处理完毕。<br>3xx（300-399）：重定向状态码，要完成请求需要进一步操作。<br>4xx（400-499）：客户端错误状态码，表示请求有语法错误或请求无法实现。<br>5xx（500-599）：服务器错误状态码，表示服务器在处理请求时发生了错误。</p><h2 id="不常见的状态码"><a href="#不常见的状态码" class="headerlink" title="不常见的状态码"></a>不常见的状态码</h2><p>101：这是一个信息性（1xx）状态码，表示服务器理解了客户端的请求，并且通过这个状态码告知客户端它将切换到请求的协议，这通常用在WebSockets协议切换中。</p><p>104: 这是一个由Nginx定义的状态码，表示连接已经重置。这通常发生在客户端取消了请求的情况下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;Connection aborted.&#x27;, ConnectionResetError(104, &#x27;Connection reset by peer&#x27;))</span><br></pre></td></tr></table></figure><p>上面的错误信息就是一个例子，它表示客户端取消了请求，导致连接被重置。出现状况是 AWS Nat Gateway 会在 30 秒内关闭空闲连接，所以在这种情况下，客户端会收到一个 104 状态码。参见文档 <a href="https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html">AWS Nat Gateway</a></p><p>499：这个状态码实际上不是一个官方的HTTP状态码，它是由Nginx定义的，用来表示客户端在服务器有机会发送回响应之前关闭了连接。也就是说，当服务器准备发送回响应，但是发现客户端已经关闭了连接时，Nginx会记录这个状态码。这通常发生在客户端取消了请求的情况下。</p><p>429: 这是一个客户端错误（4xx）状态码，表示请求过多。这个状态码通常用于限制客户端对服务器的请求频率，以防止服务器过载。注意这是一个常见的状态码，用于限制请求频率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT 发布一周年感想</title>
      <link href="/2023/11/30/chatgpt-one-year/"/>
      <url>/2023/11/30/chatgpt-one-year/</url>
      
        <content type="html"><![CDATA[<p>2022 年 11 月 30 日，ChatGPT 全球发布，开创了大语言模型的新时代。</p><p>从最开始的毫不在乎到现在的离不开，感受到的不只是震撼。</p><p>以前使用 Siri 总是觉着很蠢听不懂人话，而现在的 ChatGPT 从直观反馈来说，应该是不仅仅能听懂还能理解（所谓的人类理解），就算你中文夹杂着英文也是可以的，感觉语言的巴别塔好像被攻破了。</p><p>但是我觉着，如果将 ChatGPT 作为“好用”工具，主要体现在两点，理解需求和知识集合，这两点缺一不可，同时也相辅相成。</p><h3 id="一、理解需求"><a href="#一、理解需求" class="headerlink" title="一、理解需求"></a>一、理解需求</h3><p>很多人凭着新鲜感试用了下，感觉回答的也就很一般，不好用，甚至觉着它不明白我要问什么。可是真的是这样吗？</p><p>首先，很多人连需求都没有理清楚，而且有时候说话是有上下文的，想想看，如果一个陌生人突然问你“吃饭了吗”，你知道他究竟是什么意思吗？</p><p>GPT4 出来的时候我问了问题，它会将你的需求描述一下，按照它的理解方式去执行，这一点就很厉害了，因为现实中很多人都做不到。</p><p>当然，缺点也很明显， token 长度，就如同人的记忆，当然还是越大越好，就好像你的朋友一样，越熟悉越明白。</p><h3 id="二、知识集合"><a href="#二、知识集合" class="headerlink" title="二、知识集合"></a>二、知识集合</h3><p>ChatGPT 如果只是能理解你说的话虽然是进步但是也不会特别好用，主要是 OpenAI 这个公司整理了很多高质量数据，互联网海洋般的数据。</p><p>这一点才是我主要付费的原因，得益于互联网开放的精神，可能也恰恰是这些高质量数据才能通过量变引起质变。</p><p>现在 ChatGPT 就像一个特别好的老师，拥有整个互联网知识，而如何向老师学习在于你是如何使用的。</p><p>你可以问问题，你也可以将你理解的问题找他对答案，着实有趣。</p><p>当然，还是有一些专有知识无从获取，这点它就不如人意了，会出现一本正经的胡说八道了，这点也是广为诟病的问题。</p><p>所以它可以辅助你，但你最好是个专家能够辨别出 1% 这种级别的错误。对于编程倒是很好确定，执行下就行了，但是对于无法验证的领域就有些危险了。</p><h3 id="预测推理"><a href="#预测推理" class="headerlink" title="预测推理"></a>预测推理</h3><p>预测是我使用后最明显的感受，打字机效果的输出。通过我粗浅的分析，感觉人类也只不过是做了一些高级的预测，就好像说话一样——你真的懂你为什么说出下一个字吗？是不是脱口而出呢？</p><p>而推理如同思考一样，人脑也是，如果想一想再回答，那么效果可能会相对好些，也许 GPT 这条路可能会对人类的模拟更加进了一步！</p><h3 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h3><p>语言使人类产生文明，那么以后的人工智能时代是不是能够产生新的文明呢？</p><p>目前还不得而知，但是有一点即将发生，那就是改变生产关系。　</p>]]></content>
      
      
      
        <tags>
            
            <tag> GPT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/30/hello-world/"/>
      <url>/2023/11/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
